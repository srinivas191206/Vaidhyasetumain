<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Video Call Test</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .config-section {
            margin-bottom: 30px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #333;
        }
        
        .form-group input, .form-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e1e5e9;
            border-radius: 6px;
            font-size: 14px;
        }
        
        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #2563eb;
        }
        
        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .video-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .video-wrapper {
            position: relative;
        }
        
        .video-wrapper video {
            width: 100%;
            height: 300px;
            background: #000;
            border-radius: 8px;
            object-fit: cover;
        }
        
        .video-label {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: #2563eb;
            color: white;
        }
        
        .btn-primary:hover {
            background: #1d4ed8;
        }
        
        .btn-success {
            background: #16a34a;
            color: white;
        }
        
        .btn-success:hover {
            background: #15803d;
        }
        
        .btn-danger {
            background: #dc2626;
            color: white;
        }
        
        .btn-danger:hover {
            background: #b91c1c;
        }
        
        .btn-secondary {
            background: #6b7280;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #4b5563;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .status {
            text-align: center;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 20px;
            font-weight: 500;
        }
        
        .status.idle { background: #f3f4f6; color: #374151; }
        .status.connecting { background: #fef3c7; color: #d97706; }
        .status.connected { background: #d1fae5; color: #065f46; }
        .status.failed { background: #fee2e2; color: #dc2626; }
        
        .error {
            background: #fee2e2;
            color: #dc2626;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 20px;
            border-left: 4px solid #dc2626;
        }
        
        .info-box {
            background: #eff6ff;
            border: 1px solid #bfdbfe;
            border-radius: 6px;
            padding: 15px;
            margin: 20px 0;
        }
        
        .info-box h4 {
            margin: 0 0 10px 0;
            color: #1e40af;
        }
        
        .info-box ul {
            margin: 0;
            padding-left: 20px;
        }
        
        .info-box li {
            margin-bottom: 5px;
            color: #1e40af;
        }
        
        @media (max-width: 768px) {
            .form-row, .video-container {
                grid-template-columns: 1fr;
            }
            
            .controls {
                flex-wrap: wrap;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé• WebRTC Video Call Test</h1>
            <p>Test video calling functionality with Firebase Firestore signaling</p>
        </div>

        <!-- Configuration Section -->
        <div id="configSection" class="config-section">
            <h3>Test Configuration</h3>
            <div class="form-row">
                <div class="form-group">
                    <label for="appointmentId">Appointment ID:</label>
                    <input type="text" id="appointmentId" placeholder="Enter appointment ID">
                </div>
                <div class="form-group">
                    <label for="userId">User ID:</label>
                    <input type="text" id="userId" placeholder="Enter your user ID">
                </div>
            </div>
            
            <div class="form-row">
                <div class="form-group">
                    <label for="userRole">Your Role:</label>
                    <select id="userRole">
                        <option value="doctor">Doctor</option>
                        <option value="patient">Patient</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="otherUserName">Other User Name:</label>
                    <input type="text" id="otherUserName" placeholder="Enter other participant name">
                </div>
            </div>

            <div class="controls">
                <button id="generateDataBtn" class="btn-secondary">Generate Test Data</button>
                <button id="initializeBtn" class="btn-primary">Initialize Call</button>
            </div>

            <div class="info-box">
                <h4>Instructions:</h4>
                <ul>
                    <li>Fill in the configuration fields above</li>
                    <li>Click "Initialize Call" to prepare your camera and microphone</li>
                    <li>Doctor can start the call, Patient can join when ready</li>
                    <li>Test the video/audio controls during the call</li>
                    <li>Open this page in two different browser tabs/windows to test both roles</li>
                </ul>
            </div>
        </div>

        <!-- Video Call Section -->
        <div id="callSection" style="display: none;">
            <div id="statusDisplay" class="status idle">Ready to initialize</div>
            <div id="errorDisplay" class="error" style="display: none;"></div>

            <div class="video-container">
                <div class="video-wrapper">
                    <video id="localVideo" autoplay muted playsinline></video>
                    <div class="video-label">You (Local)</div>
                </div>
                <div class="video-wrapper">
                    <video id="remoteVideo" autoplay playsinline></video>
                    <div class="video-label">Remote Participant</div>
                </div>
            </div>

            <div class="controls">
                <button id="startCallBtn" class="btn-success" style="display: none;">üìû Start Call</button>
                <button id="joinCallBtn" class="btn-success" style="display: none;">üìû Join Call</button>
                <button id="toggleVideoBtn" class="btn-secondary" disabled>üé• Video</button>
                <button id="toggleAudioBtn" class="btn-secondary" disabled>üé§ Audio</button>
                <button id="endCallBtn" class="btn-danger" disabled>üìû End Call</button>
            </div>

            <div class="controls">
                <button id="backToConfigBtn" class="btn-secondary">‚Üê Back to Configuration</button>
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        // Import Firebase modules
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js';
        import { 
            getFirestore, 
            doc, 
            setDoc, 
            updateDoc, 
            onSnapshot, 
            deleteDoc, 
            serverTimestamp,
            getDoc
        } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js';

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDIQP3Mgu1Bpf4pfTSelrDvEBnQSbhXwQ8",
            authDomain: "hackathon-79e80.firebaseapp.com",
            projectId: "hackathon-79e80",
            storageBucket: "hackathon-79e80.appspot.com",
            messagingSenderId: "338581325054",
            appId: "1:338581325054:web:10ad1b4e1793d5a7b491af"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // WebRTC Configuration
        const rtcConfiguration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        // Global variables
        let peerConnection = null;
        let localStream = null;
        let remoteStream = null;
        let callId = null;
        let userId = null;
        let userRole = null;
        let appointmentId = null;
        let callDoc = null;
        let unsubscribeCallDoc = null;
        let unsubscribeIceCandidates = null;

        // DOM elements
        const elements = {
            configSection: document.getElementById('configSection'),
            callSection: document.getElementById('callSection'),
            appointmentIdInput: document.getElementById('appointmentId'),
            userIdInput: document.getElementById('userId'),
            userRoleSelect: document.getElementById('userRole'),
            otherUserNameInput: document.getElementById('otherUserName'),
            generateDataBtn: document.getElementById('generateDataBtn'),
            initializeBtn: document.getElementById('initializeBtn'),
            startCallBtn: document.getElementById('startCallBtn'),
            joinCallBtn: document.getElementById('joinCallBtn'),
            toggleVideoBtn: document.getElementById('toggleVideoBtn'),
            toggleAudioBtn: document.getElementById('toggleAudioBtn'),
            endCallBtn: document.getElementById('endCallBtn'),
            backToConfigBtn: document.getElementById('backToConfigBtn'),
            localVideo: document.getElementById('localVideo'),
            remoteVideo: document.getElementById('remoteVideo'),
            statusDisplay: document.getElementById('statusDisplay'),
            errorDisplay: document.getElementById('errorDisplay')
        };

        // Utility functions
        function showError(message) {
            elements.errorDisplay.textContent = message;
            elements.errorDisplay.style.display = 'block';
        }

        function hideError() {
            elements.errorDisplay.style.display = 'none';
        }

        function updateStatus(message, className = 'idle') {
            elements.statusDisplay.textContent = message;
            elements.statusDisplay.className = `status ${className}`;
        }

        function generateCallId(appointmentId) {
            return `call_${appointmentId}_${Date.now()}`;
        }

        // Event handlers
        elements.generateDataBtn.addEventListener('click', () => {
            const timestamp = Date.now();
            elements.appointmentIdInput.value = `test_appointment_${timestamp}`;
            elements.userIdInput.value = `test_user_${timestamp}`;
            elements.otherUserNameInput.value = elements.userRoleSelect.value === 'doctor' ? 'John Doe (Patient)' : 'Dr. Smith (Doctor)';
        });

        elements.initializeBtn.addEventListener('click', initializeCall);
        elements.startCallBtn.addEventListener('click', startCall);
        elements.joinCallBtn.addEventListener('click', joinCall);
        elements.toggleVideoBtn.addEventListener('click', toggleVideo);
        elements.toggleAudioBtn.addEventListener('click', toggleAudio);
        elements.endCallBtn.addEventListener('click', endCall);
        elements.backToConfigBtn.addEventListener('click', backToConfiguration);

        // Main functions
        async function initializeCall() {
            try {
                hideError();
                updateStatus('Initializing...', 'connecting');

                // Get configuration
                appointmentId = elements.appointmentIdInput.value.trim();
                userId = elements.userIdInput.value.trim();
                userRole = elements.userRoleSelect.value;

                if (!appointmentId || !userId) {
                    throw new Error('Please fill in all required fields');
                }

                callId = generateCallId(appointmentId);
                callDoc = doc(db, 'videoCalls', callId);

                // Check WebRTC support
                if (!navigator.mediaDevices || !window.RTCPeerConnection) {
                    throw new Error('WebRTC is not supported in this browser');
                }

                // Create peer connection
                peerConnection = new RTCPeerConnection(rtcConfiguration);
                setupPeerConnectionEventListeners();

                // Get user media
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true
                });

                // Display local video
                elements.localVideo.srcObject = localStream;

                // Add tracks to peer connection
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });

                // Show call interface
                elements.configSection.style.display = 'none';
                elements.callSection.style.display = 'block';

                // Show appropriate call button
                if (userRole === 'doctor') {
                    elements.startCallBtn.style.display = 'inline-block';
                } else {
                    elements.joinCallBtn.style.display = 'inline-block';
                }

                // Enable controls
                elements.toggleVideoBtn.disabled = false;
                elements.toggleAudioBtn.disabled = false;

                updateStatus('Camera and microphone ready', 'idle');

            } catch (error) {
                console.error('Initialization failed:', error);
                showError(`Initialization failed: ${error.message}`);
                updateStatus('Initialization failed', 'failed');
            }
        }

        function setupPeerConnectionEventListeners() {
            // Handle ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    saveIceCandidate(event.candidate);
                }
            };

            // Handle remote stream
            peerConnection.ontrack = (event) => {
                console.log('Remote stream received');
                remoteStream = event.streams[0];
                elements.remoteVideo.srcObject = remoteStream;
                updateStatus('Connected', 'connected');
            };

            // Handle connection state changes
            peerConnection.onconnectionstatechange = () => {
                console.log('Connection state:', peerConnection.connectionState);
                
                switch (peerConnection.connectionState) {
                    case 'connecting':
                        updateStatus('Connecting...', 'connecting');
                        break;
                    case 'connected':
                        updateStatus('Connected', 'connected');
                        break;
                    case 'disconnected':
                        updateStatus('Disconnected', 'failed');
                        break;
                    case 'failed':
                        updateStatus('Connection failed', 'failed');
                        showError('Connection failed. Please try again.');
                        break;
                }
            };
        }

        async function startCall() {
            try {
                hideError();
                updateStatus('Starting call...', 'connecting');

                // Create call document
                await setDoc(callDoc, {
                    appointmentId: appointmentId,
                    doctorId: userRole === 'doctor' ? userId : null,
                    patientId: userRole === 'patient' ? userId : null,
                    status: 'calling',
                    createdAt: serverTimestamp(),
                    offer: null,
                    answer: null
                });

                // Create offer
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);

                // Save offer to Firestore
                await updateDoc(callDoc, {
                    offer: {
                        type: offer.type,
                        sdp: offer.sdp
                    }
                });

                // Listen for answer and ICE candidates
                listenForAnswer();
                listenForIceCandidates();

                elements.startCallBtn.style.display = 'none';
                elements.endCallBtn.disabled = false;

                updateStatus('Waiting for participant to join...', 'connecting');

            } catch (error) {
                console.error('Failed to start call:', error);
                showError(`Failed to start call: ${error.message}`);
                updateStatus('Failed to start call', 'failed');
            }
        }

        async function joinCall() {
            try {
                hideError();
                updateStatus('Joining call...', 'connecting');

                // Get call document
                const callSnapshot = await getDoc(callDoc);
                if (!callSnapshot.exists()) {
                    throw new Error('Call not found');
                }

                const callData = callSnapshot.data();
                const offer = callData.offer;

                if (!offer) {
                    throw new Error('No offer found. The doctor may not have started the call yet.');
                }

                // Set remote description (offer)
                await peerConnection.setRemoteDescription(offer);

                // Create answer
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);

                // Save answer to Firestore
                await updateDoc(callDoc, {
                    answer: {
                        type: answer.type,
                        sdp: answer.sdp
                    },
                    status: 'connected',
                    [userRole === 'patient' ? 'patientId' : 'doctorId']: userId
                });

                // Listen for ICE candidates
                listenForIceCandidates();

                elements.joinCallBtn.style.display = 'none';
                elements.endCallBtn.disabled = false;

                updateStatus('Joined call', 'connected');

            } catch (error) {
                console.error('Failed to join call:', error);
                showError(`Failed to join call: ${error.message}`);
                updateStatus('Failed to join call', 'failed');
            }
        }

        function listenForAnswer() {
            unsubscribeCallDoc = onSnapshot(callDoc, (snapshot) => {
                const data = snapshot.data();
                if (data && data.answer && peerConnection && !peerConnection.remoteDescription) {
                    peerConnection.setRemoteDescription(data.answer)
                        .then(() => {
                            console.log('Remote description set from answer');
                            updateStatus('Connected', 'connected');
                        })
                        .catch(error => {
                            console.error('Error setting remote description:', error);
                            showError('Failed to establish connection');
                        });
                }
            });
        }

        function listenForIceCandidates() {
            const remoteUserId = userRole === 'doctor' ? 'patient' : 'doctor';
            const remoteCandidatesDoc = doc(db, 'videoCalls', callId, 'iceCandidates', remoteUserId);

            unsubscribeIceCandidates = onSnapshot(remoteCandidatesDoc, (snapshot) => {
                const data = snapshot.data();
                if (data && data.candidates && peerConnection) {
                    data.candidates.forEach((candidateData) => {
                        const candidate = new RTCIceCandidate(candidateData);
                        peerConnection.addIceCandidate(candidate)
                            .catch(error => console.error('Error adding ICE candidate:', error));
                    });
                }
            });
        }

        async function saveIceCandidate(candidate) {
            try {
                const candidateData = {
                    candidate: candidate.candidate,
                    sdpMLineIndex: candidate.sdpMLineIndex,
                    sdpMid: candidate.sdpMid
                };

                const iceCandidatesDoc = doc(db, 'videoCalls', callId, 'iceCandidates', userId);
                
                // Get existing candidates
                const docSnapshot = await getDoc(iceCandidatesDoc);
                const existingCandidates = docSnapshot.exists() ? docSnapshot.data().candidates || [] : [];

                // Add new candidate
                existingCandidates.push(candidateData);

                // Save to Firestore
                await setDoc(iceCandidatesDoc, {
                    candidates: existingCandidates,
                    updatedAt: serverTimestamp()
                });

            } catch (error) {
                console.error('Error saving ICE candidate:', error);
            }
        }

        function toggleVideo() {
            if (!localStream) return;

            const videoTrack = localStream.getVideoTracks()[0];
            if (videoTrack) {
                videoTrack.enabled = !videoTrack.enabled;
                elements.toggleVideoBtn.textContent = videoTrack.enabled ? 'üé• Video' : 'üö´ Video';
                elements.toggleVideoBtn.className = videoTrack.enabled ? 'btn-secondary' : 'btn-danger';
            }
        }

        function toggleAudio() {
            if (!localStream) return;

            const audioTrack = localStream.getAudioTracks()[0];
            if (audioTrack) {
                audioTrack.enabled = !audioTrack.enabled;
                elements.toggleAudioBtn.textContent = audioTrack.enabled ? 'üé§ Audio' : 'üîá Audio';
                elements.toggleAudioBtn.className = audioTrack.enabled ? 'btn-secondary' : 'btn-danger';
            }
        }

        async function endCall() {
            try {
                // Update call status in Firestore
                if (callDoc) {
                    await updateDoc(callDoc, {
                        status: 'ended',
                        endedAt: serverTimestamp(),
                        endedBy: userId
                    });
                }

                cleanup();
                updateStatus('Call ended', 'idle');

            } catch (error) {
                console.error('Error ending call:', error);
                cleanup();
            }
        }

        function cleanup() {
            // Close peer connection
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }

            // Stop local stream
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }

            // Clear video elements
            elements.localVideo.srcObject = null;
            elements.remoteVideo.srcObject = null;

            // Clean up listeners
            if (unsubscribeCallDoc) {
                unsubscribeCallDoc();
                unsubscribeCallDoc = null;
            }
            
            if (unsubscribeIceCandidates) {
                unsubscribeIceCandidates();
                unsubscribeIceCandidates = null;
            }

            // Reset UI
            elements.startCallBtn.style.display = 'none';
            elements.joinCallBtn.style.display = 'none';
            elements.endCallBtn.disabled = true;
            elements.toggleVideoBtn.disabled = true;
            elements.toggleAudioBtn.disabled = true;
            elements.toggleVideoBtn.textContent = 'üé• Video';
            elements.toggleAudioBtn.textContent = 'üé§ Audio';
            elements.toggleVideoBtn.className = 'btn-secondary';
            elements.toggleAudioBtn.className = 'btn-secondary';
        }

        function backToConfiguration() {
            cleanup();
            hideError();
            elements.callSection.style.display = 'none';
            elements.configSection.style.display = 'block';
            updateStatus('Ready to initialize', 'idle');
        }

        // Initialize with test data
        elements.generateDataBtn.click();

        // Check WebRTC support on load
        window.addEventListener('load', () => {
            if (!navigator.mediaDevices || !window.RTCPeerConnection) {
                showError('WebRTC is not supported in this browser. Please use Chrome, Firefox, or Safari.');
                elements.initializeBtn.disabled = true;
            }
        });
    </script>
</body>
</html>